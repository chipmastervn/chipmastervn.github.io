---
layout: post
title:  "Tổng quan về RTOS"
author: chipmaster
categories: [ RTOS ]
image: assets/images/image_1.webp
---
Ở bài viết này, chúng ta sẽ cùng nhau nhìn một bức tranh toàn cảnh về hệ thống nhúng.

## 1. Tổng quan

Các vi điều khiển (microcontroller) hiện đại có nhiều kích thước và mức độ phức tạp khác nhau. Một số loại chỉ có 8-bit, dưới 10 kilobytes (10K) bộ nhớ Flash và dưới 2 kilobytes (2K) RAM. Những loại cao cấp hơn có thể là vi điều khiển 64-bit đa lõi, kết nối với bộ nhớ lên đến hàng gigabyte. Ở phân khúc thấp, chúng ta thường gặp kiến trúc SoC (System on Chip). Còn ở phân khúc cao, các bo mạch SoM (System on a Module) được sử dụng nhiều hơn.

Ở các hệ thống nhỏ chỉ thực hiện một nhiệm vụ chuyên biệt, hoặc một vài nhiệm vụ cố định, như bộ điều khiển motor trong bàn chải đánh răng hoặc máy khoan điện, chúng ta có thể viết code theo kiểu **bare metal application**. Đây là cách lập trình trực tiếp lên phần cứng, không dùng hệ điều hành. Tuy nhiên, các ứng dụng hiện đại thường phức tạp và có nhiều kết nối, nên không phù hợp để xây dựng theo kiểu bare metal.

Hiện nay, nhiều nhà sản xuất vi điều khiển cung cấp các IDE (Integrated Development Environment) với giao diện đồ họa. Các IDE này giúp chúng ta cấu hình ngoại vi dễ dàng và tích hợp driver code vào dự án. Nhờ đó, bạn có thể tập trung phát triển tính năng chính cho ứng dụng. Một số ví dụ về IDE phổ biến là Harmony tool của Microchip và STM32CubeIDE của STMicroelectronics. Ngoài ra, chúng ta cũng có thể phát triển ứng dụng embedded systems bằng các IDE khác như Microsoft’s VS Code, chỉ cần cài thêm các plug-in phù hợp.

Hệ điều hành là phần mềm giúp chúng ta phát triển ứng dụng có nhiều công việc (task) chạy cùng lúc. Trung tâm của hệ điều hành là bộ lập lịch (scheduler). Scheduler quyết định task nào sẽ chạy tiếp theo. Trong hệ điều hành **cooperative multitasking**, một task sẽ chạy cho đến khi nó tự dừng và chuyển quyền điều khiển cho scheduler. Lúc này, scheduler sẽ chọn task tiếp theo để thực thi. Trong hệ điều hành **preemptive multitasking**, hệ điều hành có thể tạm dừng (preempt) một task bất cứ lúc nào. Việc này xảy ra khi có task ưu tiên cao hơn cần chạy hoặc khi task hiện tại cần dùng tài nguyên đang bị task khác sử dụng.

Khái niệm Real Time nói về thời gian hệ thống phản hồi một sự kiện, ví dụ như khi bạn nhấn nút, dữ liệu đến cổng giao tiếp hoặc quá trình chuyển đổi ADC (Analog to Digital Converter) hoàn thành. Chúng ta thường chia hệ thống real-time thành hai loại: **hard real-time** và **soft real-time**. 

- Với hard real-time, nếu hệ thống phản hồi chậm hơn thời gian quy định thì bị coi là lỗi. 
- Với soft real-time, phần lớn thời gian hệ thống đáp ứng đúng hạn, nhưng đôi khi có thể trễ mà không gây lỗi nghiêm trọng.

Trong mô hình classical bare metal multitasking, chúng ta thường dùng hai phần chính. Một phần là **superloop**, xử lý các công việc không cần chính xác về thời gian. Phần còn lại thực hiện các công việc quan trọng về thời gian, nằm trong interrupt handlers. Arduino IDE cổ điển cũng dùng cách làm này.

Trong thế giới hiện đại, các thiết bị kết nối mạng đang ngày càng phổ biến. Chúng ta có thể dùng cả mạng có dây và không dây. Các thiết bị này thường phải chạy nhiều giao thức mạng (network protocol stacks) phức tạp, và phải đảm bảo an toàn khi truyền nhận dữ liệu. Nếu chỉ dùng cách tiếp cận bare metal, chúng ta sẽ gặp nhiều khó khăn. Thiết bị mạng thường có nhiều cổng kết nối khác nhau, ví dụ như Ethernet có dây hoặc không dây, USB, hoặc các cổng nối tiếp như CAN bus, RS232, hoặc RS485. Lập trình để xử lý các cổng này rất phức tạp. Ngoài việc kết nối mạng, thiết bị còn phải làm những nhiệm vụ khác, ví dụ như đọc cảm biến theo chu kỳ. Điều này làm cho mọi thứ càng rối rắm hơn.

Các thiết bị mạng còn phải giao tiếp với nhiều thiết bị khác. Dữ liệu truyền đi và nhận về có thể không đều và rất khó đoán trước. Đôi khi thiết bị phải xử lý một lượng lớn dữ liệu dồn dập (traffic burst). Nếu không cẩn thận, hệ thống có thể bị quá tải. Vì vậy, chúng ta cần những giải pháp để bảo vệ thiết bị khỏi bị nghẽn khi có quá nhiều dữ liệu cùng lúc.

Các giao thức truyền thông theo kiểu packet-oriented như TCP/IP có cấu trúc nhiều lớp (multilayered). Một packet thường chứa nhiều header khác nhau. Mỗi header thuộc về một lớp nhất định và thực hiện chức năng riêng. Nhiều giao thức hỗ trợ multiplexing, nghĩa là chúng có thể xử lý nhiều loại dữ liệu cùng lúc. Ví dụ, TCP/IP stack có thể xử lý traffic của UDP, TCP và ICMP. Với UDP và TCP, traffic còn có thể đến từ nhiều process khác nhau trên thiết bị. Mỗi process này được xác định bằng một identifier gọi là port number.

Chúng ta có thể hiểu rằng, với cách tiếp cận multitasking, chúng ta chia nhỏ công việc thành nhiều task riêng. Sau đó, chúng ta kết hợp các task này lại nhờ các cơ chế scheduling, intertask communication và synchronization mà RTOS cung cấp. Một số cơ chế quan trọng là **semaphore** và **message queue**. Nhờ vậy, các task có thể làm việc độc lập nhưng vẫn phối hợp hiệu quả với nhau.

Động lực chính khi chúng ta dùng một RTOS để xây dựng ứng dụng nhúng là nó tạo ra một framework với các abstractions và API. Nhờ đó, bạn có thể phát triển code để xử lý thời gian, ưu tiên và khả năng preempt của các task. Điều này giúp các task hoàn thành đúng hạn và hệ thống hoạt động ổn định, dự đoán được.RTOS giống như một dịch vụ hỗ trợ. Nó không chỉ giúp lập lịch (**scheduling**), đồng bộ hóa (**synchronization**) và giao tiếp giữa các task (**intertask communication**), mà còn có thể cung cấp dịch vụ về **file system**, giao tiếp (**communication**) và bảo mật (**security**) khi cần.

## 2. RTOS là gì?

RTOS là viết tắt của **Real Time Operating System**. Operating System (hệ điều hành) là tập hợp các module, còn gọi là thư viện. Các module này giúp chúng ta quản lý và sắp xếp các task, kiểm soát cách chúng hoạt động. Task là đoạn code thực hiện một phần công việc của cả ứng dụng.

Hệ điều hành hiện đại còn cung cấp device driver để kết nối với các thiết bị và ngoại vi. Nó còn có communication protocol stack để giúp các thiết bị giao tiếp với nhau. Ngoài ra, nó cung cấp các module ở tầng ứng dụng để xây dựng ứng dụng thực tế. Hệ điều hành cũng hỗ trợ bảo mật, quản lý và bảo vệ bộ nhớ.

Chữ RT trong RTOS nghĩa là Real Time. Điều này có nghĩa là hệ điều hành này có thể xử lý công việc đúng thời điểm mà chúng ta yêu cầu.

Trong lĩnh vực công nghệ, khi chúng ta nói về Real Time, điều này có nghĩa là hệ thống hoạt động dựa trên các hành vi có thể dự đoán và lặp lại. Có hai loại chính: soft real time và hard real time.

- Với soft real time, thời gian phản hồi của hệ thống thường thay đổi theo một phân phối thống kê, ví dụ như thời gian phản hồi trung bình và mức độ dao động (mean và variance) của nó. Điều này có nghĩa là hệ thống thường phản hồi đủ nhanh, nhưng đôi khi cũng có thể chậm hơn một chút.

- Ngược lại, hard real time yêu cầu hệ thống luôn phản hồi trước một thời điểm nhất định. Nếu vượt quá thời gian cho phép, hệ thống sẽ không đáp ứng được yêu cầu và có thể gây ra sự cố nghiêm trọng.

Một số hệ thống thực tế có thể kết hợp cả hai yếu tố này, vừa có phần yêu cầu hard real time, vừa có phần chỉ cần soft real time.