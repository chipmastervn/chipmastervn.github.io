---
layout: post
title:  "Paging trong Operating System"
author: chipmaster
categories: [Memory Management]
image: assets/images/001_post.png
tags: []
---

Chúng ta đã cùng nhau tìm hiểu về cách mà hệ điều hành sử dụng kĩ thuật [Segmentation](/segmentation-sec1) trong quản lý bộ nhớ (Memory Management).

Trong bài này, chúng ta sẽ tìm hiểu thêm một kĩ thuật phổ biến khác, đó là **Paging** (phân trang).

<div class="sidebar-menu">
    <h6>Trong bài viết này</h6>
    <a href="#1stack-trong-operating-system">1. Stack trong Operating System</a>
    <a href="#2ưu-điểm-của-kĩ-thuật-segmentation">2. Ưu điểm của kĩ thuật Segmentation</a>
    <a href="#3thách-thức-của-kĩ-thuật-segmentation">3. Thách thức của kĩ thuật Segmentation</a>
</div>

<div class="mobile-menu">
    <h3>Trong bài viết này</h3>
    <ul><a href="#1stack-trong-operating-system">1. Stack trong Operating System</a></ul>
    <ul><a href="#2ưu-điểm-của-kĩ-thuật-segmentation">2. Ưu điểm của kĩ thuật Segmentation</a></ul>
    <ul><a href="#3thách-thức-của-kĩ-thuật-segmentation">3. Thách thức của kĩ thuật Segmentation</a></ul>
</div>

#### 1.Giới thiệu

Đối với kĩ thuật **Paging**, không gian địa chỉ ảo được chia thành các vùng có **kích thước cố định**, gọi là các trang (**pages**). Tương ứng, bộ nhớ vật lý cũng được chia thành các khung trang (**page frames**) có kích thước cố định, và mỗi khung trang có thể chứa một trang từ bộ nhớ ảo.
Điều này giúp giảm thiểu phân mảnh, đặc biệt là [phân mảnh ngoài](/fragmentation), vì các trang và khung trang đều có kích thước giống nhau, nên chúng có thể được quản lý dễ dàng hơn.

Tóm lại, Segmentation linh hoạt hơn nhưng dễ dẫn đến phân mảnh, trong khi Paging giảm thiểu phân mảnh bằng cách dùng các phần có kích thước cố định.

Cùng xét ví dụ sau: 

Chúng ta có không gian địa chỉ ảo (virtual address space) gồm **64 byte**, chia thành 4 trang ảo (virtual pages), mỗi trang có kích thước **16 byte**. Những trang ảo này được đánh số từ 0 đến 3.

Bộ nhớ vật lý cũng được chia thành 8 khung trang (page frames) cố định, mỗi khung trang chứa 16 byte, tạo nên bộ nhớ vật lý có tổng dung lượng là 128 byte.

Khi sử dụng phân trang, hệ điều hành chỉ cần tìm một số trang trống phù hợp trong bộ nhớ vật lý. Nếu không gian địa chỉ ảo có 64 byte và cần được lưu trữ trong bộ nhớ vật lý với 8 khung trang (mỗi khung trang chứa 16 byte), thì hệ điều hành sẽ tìm 4 khung trang trống để sử dụng.

Giả sử, hệ điều hành quyết định:
- Trang ảo 0 sẽ nằm trong khung trang vật lý 3.
- Trang ảo 1 trong khung trang 7.
- Trang ảo 2 trong khung trang 5.
- Trang ảo 3 trong khung trang 2.
- Các khung trang vật lý 1, 4, và 6 vẫn còn trống.

#### 2.Page Table

Một địa chỉ ảo là địa chỉ mà chương trình sử dụng để tham chiếu dữ liệu hoặc mã lệnh trong bộ nhớ.
Tuy nhiên, địa chỉ này không trỏ trực tiếp đến một vị trí vật lý trên RAM. Thay vào đó, nó được ánh xạ (translate) sang địa chỉ vật lý thông qua cơ chế quản lý bộ nhớ ảo.

Bảng trang (Page Table) là một cấu trúc dữ liệu mà mỗi tiến trình sử dụng để ghi lại vị trí của bộ nhớ ảo trong bộ nhớ vật lý. Hệ điều hành sử dụng **Page Table** để quản lý bộ nhớ ảo. 
Với ví dụ trước, bảng trang của tiến trình sẽ có bốn mục, thể hiện ánh xạ giữa các trang ảo (Virtual Page) và khung trang vật lý (Page Frame).
```
- VP 0 → PF 3
- VP 1 → PF 7
- VP 2 → PF 5
- VP 3 → PF 2
```

Mỗi tiến trình sẽ có bảng trang riêng, ghi lại các ánh xạ giữa trang ảo và trang vật lý của chính tiến trình đó.
Nếu có một tiến trình khác chạy, hệ điều hành sẽ quản lý bảng trang khác cho tiến trình đó vì các trang ảo của nó sẽ được ánh xạ đến các khung trang vật lý khác.

Khi dịch địa chỉ ảo, địa chỉ này được chia thành hai phần là **Virtual Page Number** và **Offset**
- Virtual Page Number (VPN): 
VPN là số trang ảo. Đây là phần đầu của địa chỉ ảo, đại diện cho trang (page) cụ thể mà địa chỉ này thuộc về.
Mỗi trang ảo có kích thước cố định, ví dụ `4KB` (4096 byte). VPN được sử dụng để tra cứu trong bảng trang (page table), giúp xác định địa chỉ trang tương ứng trong bộ nhớ vật lý.

- Offset:
Phần còn lại của địa chỉ ảo là Offset, đại diện cho vị trí cụ thể bên trong trang đó.
Vì tất cả các trang đều có cùng kích thước, Offset xác định chính xác byte nào trong trang đang được truy cập.

Khi có địa chỉ ảo, ta lấy VPN để tra Page Table và tìm ra địa chỉ vật lý của trang trong bộ nhớ. Sau đó cộng Offset để lấy vị trí cuối cùng. 

Cùng xét ví dụ sau:

Giả sử, không gian địa chỉ ảo của tiến trình là 64 byte, chia thành 4 trang ảo, mỗi trang 16 byte. Để biểu diễn 64 địa chỉ ảo cần 6 bit. 
- 2 bit đầu (VPN) để xác định trang ảo trong bộ nhớ vật lý.
- 4 bit cuối (Offset) để xác định byte cụ thể trong trang.

Nếu địa chỉ ảo là **010101**
- VPN = **01** → Trang ảo thứ 1 (VPN = 1).
- Offset = **0101** → Byte thứ 5 trong trang.

VPN = 1, tra bảng trang thấy Page Frame = 7 (111). Thay VPN bằng Page Frame trong địa chỉ ảo, nhưng giữ nguyên phần offset. Ta xác định được địa chỉ vật lý của tiến trình là **1110101**

#### 3.Nội dung và kích thước của page tables

